---
title: "Build Regression Trees"
author: "Alay Yang, Anna Qian"
date: "10/18/2018"
output: html_document
---

## SSE Function
```{r}
# input:
# P - a vector including weekly prices for the specific category in the particular store
# Y - a vector including weekly sales quantities for the specific category in the particular store
# c - a variable representing the price for the specific category

# output:
# customized SSE

get_sse <- function(P, Y, c)
{
  sse = sum(((P-c)*Y - (P-c)*mean(Y))^2)
  return (sse)
}

```


## Split
```{r}
# input:
# X - a vector including one of the marketing mix
# Y - a vector including weekly sales quantities for the specific category in the particular store
# P - a vector including weekly prices for the specific category in the particular store
# c - a variable representing the price for the specific category
# node - index of the position where the data is splited

# output:
# a new SSE for splited data

get_split_sse<-function(X,Y,P,c,position)
  {
  pos<-which(X<=X[position]) #Decision rule
  Y1<-Y[pos];  Y2<-Y[-pos]; #Split Y by set node
  P1<-P[pos];  P2<-P[-pos]; #Split P by node
  #SSE X1
  sse1<-get_sse(P1,Y1,c)
  #SSE X2
  sse2<-get_sse(P2,Y2,c)
  #Split SSE
  s_sse<- sse1+sse2
  return (s_sse)
}

```


## Find the node with minimum SSE
```{r}
# input:
# P - a vector including weekly prices for the specific category in the particular store
# X - a list of vectors including all of the marketing mix
# Y - a vector including weekly sales quantities for the specific category in the particular store
# c - a variable representing the price for the specific category
# output:
# node - a vector like (index, value, sse) indicating the node that would give the minimum SSE if we split the data there

fnd_node <- function(P, X, Y, c)
{
  node = NaN
  min_sse = get_sse(P, Y, c)
  for (i in 1:length(X)) {
    index = i # which variable
    # sort X
    X_vector = sort(X[[i]])
    for (j in 1:length(X_vector)){
      sse = get_split_sse(X_vector, Y, P, c, j)
      if (sse < min_sse){
        min_sse = sse
        value = (X_vector[j]+X_vector[j+1])/2 # where to split
        node = c(index, value, min_sse)
      }
    }
  }
  return(node)
}

```


## Build Trees
```{r}
# input:
# X - a dataframe of all the marketing mixes
# Y - a vector including weekly sales quantities for the specific category in the particular store
# P - a vector including weekly prices for the specific category in the particular store
# n - minimum number of observations in each node
# c - a variable representing the price for the specific category
# output:
# a list recording the split locations on each layer

crt_dtree<-function(X,Y,P,n,c){
  library(data.tree)
  pos = c(1:length(Y))
  tree <- Node$new("All", 
                   pred_y = mean(Y), 
                   num_nodes = length(Y),
                   pos = pos)
  
  # find the minimum observations among all nodes
  fnd_min_obs <- function(tree){
    obs <- c()
    for (i in 1:length(tree$leaves)){
      obs[i] = tree$leaves[[i]]$num_nodes
    }
    min_obs <- min(obs)
    return (min_obs)
  }
  
  # grow the tree
  # lstPos = list(1:length(Y))
  highestLevel = 1
  while(fnd_min_obs(tree) > n) {
    for (i in 1:length(tree$leaves)) {
      if (tree$leaves[[i]]$num_nodes > n && tree$leaves[[i]]$level == highestLevel) {
        # select dataframe
        X = X[tree$leaves[[i]]$pos,]
        Y = Y[tree$leaves[[i]]$pos]
        P = P[tree$leaves[[i]]$pos]
        # split
        node = fnd_node(P, X, Y, c)
        if (is.na(node)[1] == FALSE) {
          # record position
          leftPos = which(X[, node[1]] <= node[2])
          rightPos = which(X[, node[1]] > node[2])
          #lstPos[[i]] = list(pos)
          #lstPos[[i]][[2]] = which(X[, node[1]] > node[2])
          leftName = paste(colnames(X)[node[1]], "<=", node[2])
          rightName = paste(colnames(X)[node[1]], ">", node[2])
          tree$leaves[[i]]$AddChild(leftName,
                                    pred_y = mean(Y[leftPos]),
                                    num_nodes = length(Y[leftPos]),
                                    pos = leftPos)
          tree$leaves[[i]]$parent$AddChild(rightName,
                                           pred_y = mean(Y[rightPos]),
                                           num_nodes = length(Y[rightPos]),
                                           pos = rightPos)
          # recalculate # of levels
          highestLevel = highestLevel + 1
        }
        
      }
    }
  }
  
  #tree$leaves[[1]]$pos
  print(tree, "pred_y", "num_nodes", "level")
  return(tree)
  
}
```


## Prediction
```{r}
# input:
# model - customized regression tree model
# X - a vector including all of the marketing mix of the case to be predicted (a specific category in a particular store for a specific week)
# output:
# y - predicted sales quantity

crt_prediction <- function(model, X) {
  
  
}




```

